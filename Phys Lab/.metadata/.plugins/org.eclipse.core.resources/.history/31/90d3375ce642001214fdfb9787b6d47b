package utils.drawing;

import gui.activities.MainActivity;

import java.text.DecimalFormat;
import java.text.NumberFormat;

import utils.graphing.Graphable;
import utils.graphing.GraphableObject;
import utils.graphing.GraphableObjectContainer;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

public class Panel extends SurfaceView implements SurfaceHolder.Callback
{
    private DrawingThread _thread;
    private int graphType = 1;
	private GraphableObjectContainer graphable;
		
    public Panel(Context context, AttributeSet attrs, int defStyle) 
    {
        super(context, attrs, defStyle);
    }

    public Panel(Context context, AttributeSet attrs) 
    {
        super(context, attrs);
    }
    
    public Panel(Context context) 
    {
        super(context);
        getHolder().addCallback(this);
        _thread = new DrawingThread(getHolder(), this);
    }

	public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) 
	{
	}

	public void surfaceCreated(SurfaceHolder holder) 
	{
	    _thread.setRunning(true);
	    _thread.start();
	}
	 
	public void surfaceDestroyed(SurfaceHolder holder) 
	{
	    // simply copied from sample application LunarLander:
	    // we have to tell thread to shut down & wait for it to finish, or else
	    // it might touch the Surface after we return and explode
	    boolean retry = true;
	    _thread.setRunning(false);
	    while (retry) 
	    {
	        try 
	        {
	            _thread.join();
	            retry = false;
	        } catch (InterruptedException e) 
	        {
	            // we will try it again and again...
	        }
	    }
	}
	
	public void setGraphableObjectContainer(GraphableObjectContainer graphable)
	{
		this.graphable = graphable;
	}
	
	public void setGraphType(int i)
	{
		this.graphType = i;
	}
	
	
	public double roundToTwoDecimals(double d)
	{
		return ((double)Math.round(d * 100) / 100);
	}
	
	public String makeNumberSafe(double d)
	{
		if(d == 0)
		{
			return "0";
		}
		else if((d <= 100.00D && d >= 1.00D) || (d <= -1.00D && d >= -100.00D))
		{
			return ""+roundToTwoDecimals(d);
		}
		else 
		{	
			NumberFormat formatter = new DecimalFormat("0.###E0");
			//System.out.println(formatter.format(d)); // x.xxEx
			return formatter.format(d);
		}
	}
	
	public void onDraw(Canvas canvas) 
	{
		canvas.drawColor(Color.BLACK);
		Paint paint = new Paint();
		paint.setColor(Color.WHITE);
		
		Paint paintBlue = new Paint();
		paintBlue.setColor(Color.YELLOW);
		
		final int positive_leftPadding = 40;
		final int positive_rightPadding = 40;
		final int positive_bottomPadding = 20;
		final int positive_topPadding = 20;
		final int positive_horizontalAxisPadding = 0;
		final int positive_verticalAxisPadding = this.getHeight() - positive_bottomPadding;
		
		final int negative_leftPadding = 20;
		final int negative_rightPadding = 20;
		final int negative_bottomPadding = 20;
		final int negative_topPadding = 20;
		final int negative_horizontalAxisPadding = ((getWidth() - negative_rightPadding));
		final int negative_verticalAxisPadding = ((getHeight() - negative_bottomPadding));
		
		//All Quadrants
		final int both_leftPadding = 20;
		final int both_rightPadding = 20;
		final int both_bottomPadding = 20;
		final int both_topPadding = 20;
		final int both_horizontalAxisPadding = ((getWidth() - negative_leftPadding - negative_rightPadding) / 2);
		final int both_verticalAxisPadding = ((getHeight() - negative_topPadding - negative_bottomPadding) / 2);
		
		int leftPadding = 0;
		int rightPadding = 0;
		int bottomPadding = 0;
		int topPadding = 0;
		int horizontalAxisPadding;
		int verticalAxisPadding;
		
		//Positive only
		//If minvalue < 0... for the Y anyway.
			
		//X Values
		double max = 0.0D;
		double min = 0.0D;
		
		if(graphType == Graphable.GRAPH_TYPE_ACCELERATION_TIME) //A/T
		{
			max = graphable.getAccelerationTimeGraph().getMaxValue();
			min = graphable.getAccelerationTimeGraph().getMinValue();
		}
		else if(graphType == Graphable.GRAPH_TYPE_VELOCITY_TIME) //V/T
		{
			max = graphable.getVelocityTimeGraph().getMaxValue();
			min = graphable.getVelocityTimeGraph().getMinValue();
		}
		else //P/T
		{
			max = graphable.getPositionTimeGraph().getMaxValue();
			min = graphable.getPositionTimeGraph().getMinValue();
		}

		//Should be getMaxYValue() << Needs added and calculated during the sort?
		double h_max = 0.0D;
		double h_min = 0.0D;
		
		if(graphType == Graphable.GRAPH_TYPE_ACCELERATION_TIME) //A/T
		{
			h_max = graphable.getAccelerationTimeGraph().getMaxValueY();
			h_min = graphable.getAccelerationTimeGraph().getMinValueY();
		}
		else if(graphType == Graphable.GRAPH_TYPE_VELOCITY_TIME) //V/T
		{
			h_max = graphable.getVelocityTimeGraph().getMaxValueY();
			h_min = graphable.getVelocityTimeGraph().getMinValueY();
		}
		else //P/T
		{
			h_max = graphable.getPositionTimeGraph().getMaxValueY();
			h_min = graphable.getPositionTimeGraph().getMinValueY();
		}
		
		if(min >= 0.0D)
		{
			leftPadding = positive_leftPadding;
			rightPadding = positive_rightPadding;
			horizontalAxisPadding = positive_horizontalAxisPadding;
			min = 0;
		}
		else
		{
			leftPadding = negative_leftPadding;
			rightPadding = negative_rightPadding;
			horizontalAxisPadding = negative_horizontalAxisPadding;
		}
		
		if(h_min >= 0.0D)
		{
			topPadding = positive_topPadding;
			bottomPadding = positive_bottomPadding;
			verticalAxisPadding = positive_verticalAxisPadding;
			h_min = 0;
		}
		else if(h_min < 0.0D) //2 Negative quadrants
		{
			topPadding = negative_topPadding;
			bottomPadding = negative_bottomPadding;
			verticalAxisPadding = negative_verticalAxisPadding;
			h_max = 0.0D;
		}
		else //Need all 4 quadrants
		{
			topPadding = both_topPadding;
			bottomPadding = both_bottomPadding;
			verticalAxisPadding = both_verticalAxisPadding;
		}
		
		
		
		//Draw axis
		canvas.drawLine(leftPadding, verticalAxisPadding, this.getWidth() - rightPadding, verticalAxisPadding, paint);
		
		for(int i = 0; i < 5; i++)
		{
			String text = makeNumberSafe(min + ((max - min) * (i * 0.25D)));
			System.out.println("X>" + i + " " + text);
		
			Rect textBounds = new Rect();
			paint.getTextBounds(text, 0, text.length(), textBounds);
			canvas.drawText(text, 
					(int)(leftPadding + ((getWidth() - leftPadding - rightPadding) * (i * 0.25D)) - (textBounds.width() * 0.5D)), 
					verticalAxisPadding + 2 + textBounds.height() - textBounds.bottom, 
					paint);
			canvas.drawLine(leftPadding + (int)((getWidth() - leftPadding - rightPadding) * (i * 0.25D)), 
					verticalAxisPadding - 3,
					leftPadding + (int)((getWidth() - leftPadding - rightPadding) * (i * 0.25D)), 
					verticalAxisPadding + 3, 
					paintBlue);
		}
		
		//Y values
		
		//Draw axis
		canvas.drawLine(horizontalAxisPadding + leftPadding, topPadding, horizontalAxisPadding + leftPadding, this.getHeight() - bottomPadding, paint);
				
		
		for(int i = 0; i < 5; i++)
		{
			//min + ((max - min) * (i * 0.25D))
			String h_text = makeNumberSafe(h_min + ((h_max - h_min) * ((4 - i) * 0.25D)));
			System.out.println("Y>" + i + " " + h_text);
			
			Rect h_textBounds = new Rect();
			paint.getTextBounds(h_text, 0, h_text.length(), h_textBounds);
			canvas.drawText(h_text,
					horizontalAxisPadding + leftPadding - h_textBounds.width() - 2, 
					(int)(topPadding + ((getHeight() - topPadding - bottomPadding) * (i * 0.25D)) + h_textBounds.height() - (0.5D * h_textBounds.height()) - h_textBounds.bottom), 
					paint);
	
			canvas.drawLine(horizontalAxisPadding + leftPadding - 3, 
					topPadding + (int)((getHeight() - topPadding - bottomPadding) * (i * 0.25D)), 
					horizontalAxisPadding + leftPadding + 3, 
					topPadding + (int)((getHeight() - topPadding - bottomPadding) * (i * 0.25D)), 
					paintBlue);
		}
		
	}
}